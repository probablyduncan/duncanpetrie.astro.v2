---
import type { PhotoName } from "../../data/photoTypes.generated";
import { resolveImage, type Image } from "../../lib/photoHelper";
import SmartImage from "../prose_components/smartImage.astro";
import { toSeveral, type SingleOrSeveral } from "../../lib/singleOrSeveral";
import { resolveLink } from "../../lib/linkHelper";
import type { ContentEntryMap } from "astro:content";
import { getEntry } from "astro:content";
import MdLink from "../prose_components/mdLink.astro";

interface Props {
    key: ContentEntryMap["homepage"][keyof ContentEntryMap["homepage"]]["slug"];
    largeImage?: boolean;
    shuffle?: boolean;
    images?: SingleOrSeveral<Image>;
    photos?: SingleOrSeveral<PhotoName>;
    srcs?: SingleOrSeveral<string>;
}

const {
    key,
    largeImage = false,
    shuffle = false,
    photos = [],
    srcs = [],
    images = [],
} = Astro.props;

const props = await getEntry("homepage", key);
const { Content } = await props.render();

const resolvedImages = Promise.all(toSeveral(images).map(async image => await resolveImage(image)))
const resolvedPhotos = Promise.all(toSeveral(photos).map(async photoName => await resolveImage({ photoName })));
const resolvedSrcs = Promise.all(toSeveral(srcs).map(async src => await resolveImage({ src })));

const allImages: Image[] = (await resolvedImages)
    .concat(await resolvedPhotos)
    .concat(await resolvedSrcs);

// if href is true, resolve link from name of mdx snippet
let href: string;
if (props.data.href === true) {
    href = key;
}
else if (props.data.href === false) {
    href = "";
}
else {
    href = props.data.href;
}

const resolvedLink = props.data.href ? resolveLink({ href, title: props.data.title }) : {};

const guid = Math.random() * 1000;

const titleIconSpace = props.data.iconSpace === "both" || props.data.iconSpace === "title";
const bottomIconSpace = props.data.iconSpace === "both" || props.data.iconSpace === "bottom";
---

<section>
    <div class:list={{ 
        swiper: true,
        "opacity-0 transition-opacity": true,
        shuffle,
    }}>
        <div class="swiper-wrapper">
            {
                allImages.map((image) => (
                    <div class="swiper-slide">
                        <div class="flex justify-center px-4">
                            <div class:list={[largeImage ? "max-w-xl" : "max-w-md", "w-full"]}>
                                <SmartImage {...image} caption="none" lazy={true} />
                            </div>
                        </div>
                    </div>
                ))
            }
        </div>
    </div>
    <div class="flex flex-col items-center px-5">
        <div class="max-w-md">
            <div class="font-medium text-right text-xs mt-1">
                <slot name="underimage" />
            </div>
            <h1
                class:list={[
                    "font-serif mt-8",
                    props.data.smallTitle ? "sm:text-4xl text-3xl" : "text-5xl",
                    { ligatures: props.data.titleLigatures },
                ]}
            >
                {props.data.href ? (<a {...resolvedLink} class="hover:underline focus:outline-black">{props.data.title}</a>) : (<>{props.data.title}</>)}<sup>{titleIconSpace  ? " " : ""}<button tabindex="-1" class="transition-transform hover:rotate-12" data-icon={guid}>{props.data.icon}</button></sup>
            </h1>
            <div
                class="relative [&_>*]:pt-4 [&_>p:first-of-type]:arrow-indent hyphens-none pr-4"
            >
                <Content components={{ a: MdLink }} />
            </div>
            <div class:list={{"bg-black text-white invert": !!props.data.href}}>
                <a {...resolvedLink} tabindex="-1" data-icon={guid} class:list={{
                    "relative flex justify-between items-end mt-36 pt-1 px-1 pb-0.5 border-b-[3px]": true,
                    "text-black border-black": !props.data.href,
                    "text-white border-white": !!props.data.href,
                    "after:absolute after:top-0 after:right-0 after:bottom-0 after:left-0": !!props.data.href,
                    "after:origin-left after:scale-x-0 after:transition-transform": !!props.data.href,
                    "after:bg-white after:mix-blend-difference after:content-['']": !!props.data.href,
                    "focus:outline-none focus:after:transform-none hover:after:transform-none data-[focusing]:after:transform-none": !!props.data.href,
                }}>
                    <slot name="bottomleft">
                        <span class="italic">
                            <span class:list={{"font-serif text-lg": true, "pr-1": bottomIconSpace}}>{props.data.icon}</span>
                            <span>{props.data.bottomLine}</span>
                        </span>
                    </slot>
                    <slot name="bottomright">
                        <span class="text-xl">-&gt;</span>
                    </slot>
                </a>
            </div>
        </div>
    </div>
</section>
<script>
    import Swiper from "swiper";
    import "swiper/css";
    import { shuffleRef } from "../../lib/shuffle"

    document.addEventListener("DOMContentLoaded", function () {

        document.querySelectorAll(".swiper.shuffle").forEach((e) => {
            const slideContainer = e.children[0];
            const slides = Array.from(slideContainer.children);
            shuffleRef(slides);
            slideContainer.replaceChildren(...slides);
        });

        new Swiper(".swiper", {
            grabCursor: true,
            // loop: true,
            on: {
                init: (s) => {
                    requestAnimationFrame(() => {
                        s.el.style.opacity = "1";
                    })
                }
            }
        });

        document.querySelectorAll("button[data-icon]").forEach(e => {
            const button = (e as HTMLButtonElement);
            const guid = button.dataset.icon;
            button.addEventListener("click", () => {
                const target = document.querySelector(`:not(button)[data-icon="${guid}"]`) as HTMLElement;
                
                window.scrollTo({
                    top: target.offsetTop + (target.offsetParent as HTMLElement).offsetTop - (window.innerHeight*3/4),
                    behavior: "smooth",
                });

                setTimeout(() => {

                    target.dataset.focusing = "true";

                    setTimeout(() => {
                        delete target.dataset.focusing;
                    }, 800);

                }, 200);
            })
        });
    });
</script>
