---
import type { RoughAnnotationType } from "rough-notation/lib/model";
import SmartLink from "./smartLink.astro";

interface Props {
    type?: RoughAnnotationType;
    staticUnderline?: boolean;
    href?: string;
    title?: string;
}

const {
    type = "underline",
    staticUnderline = true,
    ...passthrough
} = Astro.props;
---

<SmartLink
    {...passthrough}
    data-type={type}
    class:list={{
        "annotated-link focus-visible:outline-none": true,
        "hover:opacity-80 focus-visible:opacity-80 transition-opacity":
            type === "circle" || type === "box",
        "hover:text-white focus-visible:text-white": type === "highlight",
        "underline hover:no-underline": staticUnderline,
    }}><slot /></SmartLink
><script>
    //the script tag here is on the same line to prevent white space injection
    import { annotate } from "rough-notation";
    import type {
        RoughAnnotation,
        RoughAnnotationConfig,
        RoughAnnotationType,
    } from "rough-notation/lib/model";

    (() => {
        const annotationArray: RoughAnnotation[] = [];

        function cleanupAnnotations() {
            // Force a mouseleave event on all annotated links
            document.querySelectorAll("a.annotated-link").forEach((link) => {
                // Dispatch a synthetic mouseleave event
                const leaveEvent = new MouseEvent("mouseleave", {
                    bubbles: true,
                    cancelable: true,
                    view: window,
                });
                link.dispatchEvent(leaveEvent);

                // Also remove any hover-related classes or states
                link.classList.remove("hover");
                delete (link as any).dataset.hovering;

                // Force blur state
                if (document.activeElement === link) {
                    (document.activeElement as HTMLElement).blur();
                }
            });

            // First hide all annotations
            annotationArray.forEach((a) => {
                if (a.isShowing()) {
                    a.hide();
                }
            });

            // Manually remove any SVG elements that might still be in the DOM
            document.querySelectorAll("svg.rough-annotation").forEach((svg) => {
                svg.remove();
            });

            // Clear the array
            annotationArray.length = 0;
        }

        function createAnnotationConfig(
            type: RoughAnnotationType
        ): RoughAnnotationConfig {
            const config: RoughAnnotationConfig = {
                type,
                color: "black",
                multiline: true,
            };

            switch (type) {
                case "circle":
                    config.animationDuration = 300;
                    config.iterations = 1;
                    config.padding = [5, 10];
                    break;
                case "highlight":
                    config.animationDuration = 450;
                    break;
                case "box":
                    config.animationDuration = 300;
                    config.iterations = 1;
                    config.padding = [5, 10];
                    break;
                case "underline":
                    config.animationDuration = 200;
                    config.strokeWidth = 3;
                    config.iterations = 1;
                    config.padding = [0, 0];
                    break;
            }

            return config;
        }

        function initAnnotatedLinks() {
            cleanupAnnotations();

            // const colors = ['salmon', 'cornflowerblue', 'coral', 'darkolivegreen', 'darkseagreen', 'darkslategrey', 'indianred', 'orangered']
            // const color = colors[Math.floor(Math.random() * colors.length)];

            document.querySelectorAll("a.annotated-link").forEach((_e) => {
                const element = _e as HTMLAnchorElement;
                const type: RoughAnnotationType = element.dataset
                    .type as RoughAnnotationType;

                if (!type) {
                    return;
                }

                const annotation = annotate(
                    element,
                    createAnnotationConfig(type)
                );

                annotationArray.push(annotation);

                function showAnimated() {
                    if (!annotation.isShowing()) {
                        annotation.animate = true;
                        annotation.show();
                    }
                }

                function showStatic() {
                    if (!annotation.isShowing()) {
                        annotation.animate = false;
                        annotation.show();
                    }
                }

                function hide() {
                    if (annotation.isShowing()) {
                        annotation.hide();
                    }
                }

                // hover effects
                element.addEventListener("mouseenter", showAnimated);
                element.addEventListener("mouseleave", hide);

                // focus effects
                element.addEventListener("focusin", showStatic);
                element.addEventListener("focusout", hide);

                element.addEventListener("click", hide);

                // Store event listeners for cleanup
                const listeners = {
                    mouseenter: showAnimated,
                    mouseleave: hide,
                    focusin: showStatic,
                    focusout: hide,
                    click: hide,
                };

                // Add listeners
                Object.entries(listeners).forEach(([event, handler]) => {
                    element.addEventListener(event, handler, { passive: true });
                });

                // Store cleanup function
                element.dataset.cleanupAnnotation = "true";

                // Add cleanup function to remove listeners when needed
                const cleanup = () => {
                    Object.entries(listeners).forEach(([event, handler]) => {
                        element.removeEventListener(event, handler);
                    });
                    delete element.dataset.cleanupAnnotation;
                };

                // Store cleanup reference
                (element as any)._cleanupAnnotation = cleanup;
            });
        }

        // Handle page visibility changes
        document.addEventListener("visibilitychange", () => {
            if (document.visibilityState === "hidden") {
                cleanupAnnotations();
            }
        });

        // Handle page cache
        window.addEventListener("pagehide", (e) => {
            cleanupAnnotations();

            // Clean up event listeners
            document
                .querySelectorAll("[data-cleanup-annotation]")
                .forEach((el) => {
                    if ((el as any)._cleanupAnnotation) {
                        (el as any)._cleanupAnnotation();
                    }
                });
        });

        // Handle page show (when coming back from cache)
        window.addEventListener("pageshow", (e) => {
            if (e.persisted) {
                cleanupAnnotations();
                initAnnotatedLinks(); // Reinitialize if coming from cache
            }
        });

        // Initialize on first load
        initAnnotatedLinks();
        document.addEventListener("astro:after-swap", initAnnotatedLinks);

        new MutationObserver((mutations) => {
            mutations.forEach((mutation) => {
                if (mutation.addedNodes.length > 0) {
                    console.log("Added nodes:", mutation.addedNodes);
                }
                if (mutation.removedNodes.length > 0) {
                    console.log("Removed nodes:", mutation.removedNodes);
                }
            });
        }).observe(document.body, { childList: true, subtree: true });
    })();
</script>
